# Tree-Related Topics

## 1. Binary Tree (BT)

- Implement a binary tree (not BST)
- Binary tree vs. Binary Search Tree (BST)
- Time complexity of search, insert, and other operations in binary tree
- Level order traversal of binary tree (Leetcode 102)
- Preorder traversal
- Postorder traversal
- Check if a tree is balanced or not
- Height and depth of a node in a binary tree
- Complete tree vs. full tree vs. perfect tree
- Degenerate tree
- Ternary tree
- N-ary tree
- Segment tree
- Lowest Common Ancestor (LCA)
- Check if two trees are identical
- Check if a subtree exists
- Internal nodes
- Siblings
- Degree of a node vs. degree of a tree
- Applications of trees
- Printing all leaf nodes in a tree

## 2. Binary Search Tree (BST)

- BST implementation
- Applications of BST
- BST vs. heap
- Validate if a tree is a BST (including negative scenarios)
- BST insertion complexity
- BST deletion (including special cases)
- Find height of BST
- Find kth smallest element in BST (Leetcode 230, using inorder traversal)
- Find kth largest element in BST
- Find second largest element in BST
- Find third largest element in BST
- Find element closest to a target element in BST
- Count single child nodes in BST
- Allow duplicate elements in BST
- Find minimum in BST using recursion
- Complexity of removing the second largest element
- Balanced vs. unbalanced BST
- Time complexity differences between BST and binary tree operations

## 3. Self-Balancing Trees

- AVL tree (needs clarity)
- Red-black tree (needs clarity)
- Rotations in AVL trees
- B-tree
- Balanced vs. unbalanced tree concepts

---

# Trie-Related Topics

## 1. Trie (Prefix Tree)

- Implement a trie (90% solved)
- Types of tries (suffix trie vs. prefix trie, compressed trie)
- Applications of tries
- Auto-completion/word suggestion using trie
- Longest prefix in a trie
- Search a word in a trie
- Prefix search in trie
- Insert new word in trie
- Deletion in trie
- Trie serialization and deserialization
- Advantages of tries
- Complexity of trie operations
- Self-balancing trie (learn more)
- Find the longest non-repeating substring in a string

---

# Graph-Related Topics

## 1. Graph Fundamentals

- Graph implementation (adjacency list, adjacency matrix)
- Types of graphs (directed vs. undirected, weighted vs. unweighted, connected vs. disconnected, bipartite, complete)
- Applications of graphs (e.g., social media mutual friends, weighted graph applications)
- Tree vs. graph
- Adjacency (list vs. matrix)
- Degree of a vertex
- Degree of a node vs. degree of a tree
- Graph indexing
- Represent a graph in memory
- Complexity of graph initialization

## 2. Graph Algorithms

- Breadth-First Search (BFS) implementation and complexity
- Depth-First Search (DFS) implementation and complexity
- Backtracking in DFS
- Shortest path in a graph (weighted and unweighted, BFS, Dijkstra’s algorithm)
- Minimum Spanning Tree (Prim’s algorithm, Kruskal’s algorithm)
- Cycle detection in a graph
- Count cycles in a graph
- Find shortest distance between two vertices
- Number of islands (Leetcode 200)
- Clone graph (Leetcode 133)
- Data structures used for DFS and BFS traversal

## 3. Graph Traversals

- BFS and DFS traversal methods
- Complexity of BFS and DFS in graphs

---

# Heap-Related Topics

## 1. Heap Fundamentals

- Implement a heap (min heap, max heap, 90% solved for max heap)
- Heap sort implementation (needs clarity)
- Heapify (up and down)
- Time complexity of heap sort
- Time complexity of insert operation in a heap
- Delete node from heap (min heap, general)
- Conversion of min heap to max heap
- Applications of heaps
- Priority queue and heap
- Implement priority queue
- Is heap a complete binary tree?
- Find the right child of a heap
- Top K frequent elements using heap
- Kth largest element in an array using heap
- Limitations of heaps

---

# General Data Structure and Algorithm Topics

## 1. Time Complexity and Analysis

- Quadratic time complexity
- Linear time complexity
- Logarithmic values and functions
- Complexity analysis (Big O notation)
- Time complexity of all data structures (tree, graph, trie, heap)
- Time complexity of search in a balanced tree
- Complexity of BFS and DFS in graphs
- Complexity of trie operations
- Complexity of BST insertion and other operations

## 2. Hashing

- Implementation using hash table
- Applications of hash table
- Hashing functions

## 3. Other Algorithms and Techniques

- Sliding window pattern
- Find combination of numbers summing to a target (e.g., sum = 2 for array [1,2,-3,5,0,4,-8,-5,7,-9,-7,3])
- Binary search
- Delete middle element from a linked list
- Find unique characters from a given string
- Advantages of recursion
- Sum of elements in an array using recursion

## 4. Practice and Problem Solving

- Practice problems from Blind 75 Leetcode (e.g., Leetcode 215, 133, 102, 230, 200)
- Learn optimal solutions by watching YouTube videos
- Solve problems on platforms like LeetCode, HackerRank, and GeeksforGeeks
- Improve coding speed
- Learn to read errors and debug code
- Practice logical workouts and application-level programs
